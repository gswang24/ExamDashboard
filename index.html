<script>
        // ... (保留原本上方的代碼直到 initResizable) ...

        // --- Resizer 邏輯 (v9.21 修正跳動問題) ---
        function initResizable() {
            const setupResizer = (resizerId, targetId, direction, isBottomAnchor = false) => {
                const resizer = document.getElementById(resizerId);
                const target = document.getElementById(targetId);
                if (!resizer || !target) return;

                let startPos = 0, startSize = 0;

                const onStart = (e) => {
                    // 防止觸控時的默認滾動
                    if (e.type === 'touchstart') {
                        // e.preventDefault(); // 視情況開啟，有些瀏覽器需要保留滾動
                    }
                    
                    startPos = direction === 'width' ? (e.type.includes('touch')?e.touches[0].clientX:e.clientX) : (e.type.includes('touch')?e.touches[0].clientY:e.clientY);
                    
                    const rect = target.getBoundingClientRect();
                    startSize = direction === 'width' ? rect.width : rect.height;
                    
                    // --- 修正重點：先鎖定當前尺寸，再移除 flex 屬性 ---
                    // 這樣可以防止元素瞬間縮回 min-width 造成的跳動
                    if (direction === 'width') {
                        target.style.width = startSize + 'px';
                    } else {
                        target.style.height = startSize + 'px';
                    }
                    // ---------------------------------------------

                    target.style.flex = 'none';

                    document.body.classList.add('is-resizing');
                    if(direction !== 'width') document.body.classList.add('row-resize');
                    
                    window.addEventListener('mousemove', onMove); window.addEventListener('touchmove', onMove, {passive:false});
                    window.addEventListener('mouseup', onEnd); window.addEventListener('touchend', onEnd);
                };

                const onMove = (e) => {
                    if (e.type === 'touchmove') e.preventDefault(); // 防止拖曳時畫面捲動
                    
                    let curr = direction === 'width' ? (e.type.includes('touch')?e.touches[0].clientX:e.clientX) : (e.type.includes('touch')?e.touches[0].clientY:e.clientY);
                    
                    // 計算新的尺寸
                    let newSize = isBottomAnchor ? startSize + (startPos - curr) : startSize + (curr - startPos);
                    
                    // 設定最小限制，避免縮太小破版
                    if (newSize > 50) { 
                        if (direction === 'width') {
                            target.style.width = newSize + 'px';
                        } else { 
                            target.style.height = newSize + 'px'; 
                        }
                    }
                };

                const onEnd = () => {
                    document.body.classList.remove('is-resizing'); 
                    document.body.classList.remove('row-resize');
                    window.removeEventListener('mousemove', onMove); window.removeEventListener('touchmove', onMove);
                    window.removeEventListener('mouseup', onEnd); window.removeEventListener('touchend', onEnd);
                };

                resizer.addEventListener('mousedown', onStart); 
                resizer.addEventListener('touchstart', onStart, {passive:false});
            };

            // 設定各個 Resizer
            setupResizer('resizerHeader', 'clockCard', 'width');   
            setupResizer('resizerMain', 'headerRow', 'height');    
            setupResizer('resizerContent', 'scheduleCol', 'width'); 
            setupResizer('resizerSubjectSplit', 'attendanceCard', 'height', true);
        }
        
        window.addEventListener('DOMContentLoaded', initResizable);

        // ... (保留原本下方的 ResizeObserver 和其他邏輯) ...
    </script>
